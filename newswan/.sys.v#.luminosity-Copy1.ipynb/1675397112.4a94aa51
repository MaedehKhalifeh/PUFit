{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "31aa1a78",
   "metadata": {},
   "outputs": [],
   "source": [
    "from __future__ import annotations\n",
    "import uproot\n",
    "import warnings\n",
    "import sys\n",
    "if not sys.warnoptions:\n",
    "    warnings.simplefilter(\"ignore\")\n",
    "    \n",
    "import plotly\n",
    "import plotly.graph_objects as go\n",
    "import plotly.express as px\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "\n",
    "from plotly.subplots import make_subplots\n",
    "from typing import overload\n",
    "from abc import ABC, abstractmethod\n",
    "import numpy as np\n",
    "import sympy\n",
    "from sympy.integrals.transforms import laplace_transform\n",
    "import random\n",
    "import math\n",
    "from tqdm.auto import tqdm, trange\n",
    "from concurrent.futures import ThreadPoolExecutor\n",
    "import scipy.stats as stats\n",
    "from scipy.optimize import curve_fit\n",
    "\n",
    "\n",
    "from Class1 import parametricValue\n",
    "\n",
    "    \n",
    "from Class1 import fixedValue\n",
    "\n",
    "\n",
    "from Class1 import parametricValueNumpy\n",
    "\n",
    "\n",
    "from Class1 import parametricValueSympy\n",
    "\n",
    "\n",
    "#these are important for me:\n",
    "\n",
    "from Class1 import binning\n",
    "\n",
    "\n",
    "from Class1 import discretepdf\n",
    "\n",
    "\n",
    "from Class1 import NLL\n",
    "\n",
    "\n",
    "from Class1 import lumiDist\n",
    "\n",
    "\n",
    "from Class1 import lumiDistSympyLaplace\n",
    "\n",
    "\n",
    "from Class1 import lumiDistNumpy\n",
    "\n",
    "\n",
    "from Class1 import SimulationVSPu\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b494c69b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# گرفتن انتگرال pu dist\n",
    "\n",
    "bina = binning(1 , 2 , 1.5 )\n",
    "binb = binning(2 , 3 , 2.5)\n",
    "binc = binning(3, 4 , 3.5)\n",
    "lumidist = lumiDistNumpy('testlumi' , {bina: 0.33 , binb: 0.33 , binc: 0.33 #lumi bin prob\n",
    "                                      }, 50 , np.array([1,2,2.5] # pu max and cross section for each bin \n",
    "                                                      ))\n",
    "g = lumidist.PUDist.plot(param = 1)\n",
    "lumidist.PUDist.plot(param = 2 , g=g )\n",
    "lumidist.PUDist.plot(param = 3 , g=g )\n",
    "\n",
    "\n",
    "g.update_layout(\n",
    "        title=\"PU dist \",\n",
    "        xaxis_title= 'PU',\n",
    "        yaxis_title=\"probability\",\n",
    "        legend_title=\"PU number\",\n",
    "    )\n",
    "g"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0de87d17",
   "metadata": {},
   "outputs": [],
   "source": [
    "bina.representative"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "89c793fd",
   "metadata": {},
   "outputs": [],
   "source": [
    "# counter = 0\n",
    "# for b,v in lumidist.PUDist.vals:\n",
    "#     counter +=1\n",
    "#     print(b,v)\n",
    "# print(counter)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "43397eda",
   "metadata": {},
   "outputs": [],
   "source": [
    "from Class1 import RunInfo\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "817337d8",
   "metadata": {},
   "outputs": [],
   "source": [
    "web2 = '/eos/user/c/cmstandi/www/PU/newres/test10/eraB-allruns'\n",
    "from pathlib import Path\n",
    "\n",
    "import sys\n",
    "sys.path.append('../nTuplizer')\n",
    "\n",
    "from allInfo import GetAllRuns, GetAllEras\n",
    "\n",
    "def export_graph(g , n , pname, pdir):\n",
    "    ghtml = g.to_html()\n",
    "    Path('{0}/{1}/'.format(pdir , pname) ).mkdir(parents=True, exist_ok=True)\n",
    "    with open('{0}/{1}/{2}.html'.format(pdir , pname , n) , 'w') as f:\n",
    "        f.write(ghtml)\n",
    "def publish_res(rinfo , gchi2 , vname ,  name , publish_dir):\n",
    "\n",
    "    \n",
    "    \n",
    "    \n",
    "    gg = rinfo.plot_lumi_distribution(subRuns=-1 , colorLumiScale=4 , density=False)\n",
    "    gg.update_layout(\n",
    "        title=\"Distribution of BX luminosity\",\n",
    "        xaxis_title='luminosity (1/mb 1/25ns)',\n",
    "        yaxis_title=\"probability\",\n",
    "        legend_title=\"Runs\",\n",
    "    )\n",
    "    export_graph(gg , '01-lumi_distribution' , name , publish_dir)\n",
    "    \n",
    "    \n",
    "    \n",
    "    \n",
    "    #02-pu_distribution\n",
    "    \n",
    "    gg = rinfo.plotPUDists(70)\n",
    "    export_graph(gg , '02-pu_distribution' , name , publish_dir)\n",
    "    \n",
    "    \n",
    "    \n",
    "    \n",
    "    \n",
    "    #03-{vname}_distribution:\n",
    "    \n",
    "    if rinfo.parentRun is None:\n",
    "        gg = rinfo.plotDataDist(zoom=True)\n",
    "        export_graph(gg , '03-{0}_distribution'.format(vname) , name , publish_dir) \n",
    "\n",
    "    \n",
    "    \n",
    "    \n",
    "    #04-{vname}_predictions:\n",
    "\n",
    "    gg = rinfo.plotPredictions([60,65,75,80,90])\n",
    "    export_graph(gg , '04-{0}_predictions'.format(vname) , name , publish_dir)\n",
    "    \n",
    "        \n",
    "        \n",
    "        \n",
    "        \n",
    "    for _xsec in [60,65,75,80,90]:\n",
    "        gg = rinfo.plotRunPredictions(_xsec)\n",
    "        export_graph(gg , '05-{0}_predictions_xsec{1}'.format(vname , _xsec) , name , publish_dir)\n",
    "            \n",
    "    \n",
    "    \n",
    "    export_graph(gchi2 , '06-bestfit_details'  , name , publish_dir)\n",
    "    export_graph(rinfo.postFitPlots(), '07-postFit_plots'  , name , publish_dir)\n",
    "    export_graph(rinfo.pullPlots(50 , 1.3) , '08-pullPlots' , name , publish_dir)\n",
    "    export_graph(rinfo.NadjiehPullPlots(50 , 1.3) , '08-NadjiehPullPlots' , name , publish_dir)\n",
    "    \n",
    "    \n",
    "    \n",
    "    \n",
    "    \n",
    "    if rinfo.parentRun is None:\n",
    "        export_graph(rinfo.aggregateFitRes() , '09-summary1' , name ,publish_dir)\n",
    "        export_graph(rinfo.aggregateFitRes2() , '09-summary2' , name ,publish_dir)\n",
    "        export_graph(rinfo.aggregateFitRes3() , '09-summary3' , name ,publish_dir)\n",
    "        export_graph(rinfo.aggregateFitRes4() , '09-summary4' , name ,publish_dir)\n",
    "        \n",
    "        \n",
    "   \n",
    "rinfo = None\n",
    "        \n",
    "def process_and_publish(year , era , vname , vmin , vmax , vnbins , pu_max ,\n",
    "                        lumiName = 'PHYSICSDel' , \n",
    "#                         lumiQ =  np.array([0,0.2,0.6,1.0]) ,\n",
    "                        lumiQ =  np.array([0,1.0]) ,\n",
    "                        lnbins_per_q = 100 ,\n",
    "                        xsec = np.arange(30,100,1), nthreads = 30 , publish_dir = \n",
    "                        web2 ):\n",
    "    nbins = lumiQ.size -1\n",
    "  #  print(nbins)    \n",
    "\n",
    "    name = '{0}{1}/{2}'.format(era, year , vname)\n",
    "    \n",
    "    \n",
    "    #00simulation plot:\n",
    "    \n",
    "    var_bins = np.linspace(vmin,vmax,vnbins+1)\n",
    "    simDist = SimulationVSPu(vname , year = year , var_bins=var_bins , pu_max=pu_max , nthreads=nthreads)\n",
    "\n",
    "\n",
    "    g = simDist.plot(param=1 , label = 'PU = 1')\n",
    "    for i in range(10,90+1,10):\n",
    "        theName = 'PU = {0}'.format(i)\n",
    "        simDist.plot(param=i , g=g , \n",
    "                     scatterOpts={ 'name':theName}\n",
    "                    )\n",
    "\n",
    "    g.update_layout(\n",
    "        title=\"Simulated distribution for PU \",\n",
    "        xaxis_title= vname,\n",
    "        yaxis_title=\"probability\",\n",
    "        legend_title=\"PU number\",\n",
    "    )    \n",
    "    export_graph(g , '00-Simulation' , name , publish_dir )\n",
    "    \n",
    "    \n",
    "    \n",
    "    \n",
    "    #Runs:\n",
    "    \n",
    "    allRuns = sorted( list(set( GetAllRuns(year , era) ) ) )\n",
    "#     allRuns = allRuns[22:23]\n",
    "#     print(allRuns)\n",
    "    \n",
    "    \n",
    "    \n",
    "    print('is going to run over {0} runs'.format( len(allRuns)) )\n",
    "    print('Number of Lumi Bins = {0}'.format(nbins))\n",
    "\n",
    "    \n",
    "    rinfo = RunInfo(0 , vname , var_bins , lumiName ,lumiQ , nbins_perq=lnbins_per_q , sub_runs=allRuns , \n",
    "                    nthreads=nthreads , xsecs = xsec )\n",
    "    \n",
    "    rinfo.setSimulation(simDist)\n",
    "    gchi2 = rinfo.fit()\n",
    "    \n",
    "#     print(vname)\n",
    "#     print(var_bins)\n",
    "#     print(lumiName)\n",
    "#     print(lumiQ)\n",
    "#     print(lnbins_per_q)\n",
    "    \n",
    "    try:\n",
    "        publish_res(rinfo , gchi2 , vname , name , publish_dir)\n",
    "        for sr in rinfo._subRuns : #+ rinfo._subRunsSameLumiBins:\n",
    "            #ext = '/SRSimilarBinning' if sr._isSecondHand else '/SRSameBinning'\n",
    "            publish_res(sr , None , vname , vname , '{0}/{1}{2}/Runs/Run{3}'.format(publish_dir , era, year , sr.run) )\n",
    "    except Exception as e:\n",
    "        print(e)\n",
    "        return rinfo\n",
    "    #del rinfo\n",
    "    #del simDist\n",
    "    return rinfo\n",
    "\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c6d65bd9",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "variables = { \n",
    "              \"nVertices\" : ( \"nVertices\" , 90 , 0 , 90 ) ,\n",
    "              \"nGoodVertices\" : (\"nGoodVertices\", 80, 0 , 80) ,\n",
    "              \"nEles\" : (\"nEles\" , 10 , 0 , 10 ) ,\n",
    "              \"nMus\" : (\"nMus\" , 10 , 0 , 10 ),\n",
    "              \"nChargedHadrons\" : (\"nChargedHadrons\" , 120 , 0 , 1200 ),\n",
    "              \"nLostTracks\": (\"nLostTracks\" , 35 , 0 , 35 ),\n",
    "              \"nPhotons\" : (\"nPhotons\" , 120 , 0 , 600 ),\n",
    "              \"nNeutralHadrons\" : (\"nNeutralHadrons\" , 60 , 0 , 120 ),\n",
    "              \"fixedGridRhoAll\" : (\"fixedGridRhoAll\" , 40 , 0 , 40 ),\n",
    "              \"fixedGridRhoFastjetAll\" : (\"fixedGridRhoFastjetAll\" , 40 , 0 , 40 ),\n",
    "              \"fixedGridRhoFastjetAllCalo\" : (\"fixedGridRhoFastjetAllCalo\" , 25 , 0 , 25 ),\n",
    "              \"fixedGridRhoFastjetCentral\" : (\"fixedGridRhoFastjetCentral\" , 50 , 0 , 50 ),\n",
    "              \"fixedGridRhoFastjetCentralCalo\" : (\"fixedGridRhoFastjetCentralCalo\" , 20 , 0 , 20 ),\n",
    "              \"fixedGridRhoFastjetCentralChargedPileUp\" : (\"fixedGridRhoFastjetCentralChargedPileUp\" , 35 , 0 , 35 ),\n",
    "              \"fixedGridRhoFastjetCentralNeutral\" : (\"fixedGridRhoFastjetCentralNeutral\" , 12 , 0 , 12 )\n",
    "            }\n",
    "\n",
    "vvv = {}\n",
    "for v,vinfo in variables.items():\n",
    "     vvv[v] = process_and_publish(2018 , 'B' , vinfo[0] , vinfo[2] , vinfo[3] , vinfo[1] , 90  )\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "08b6ae86",
   "metadata": {},
   "outputs": [],
   "source": [
    "for key in vvv:\n",
    "    for i in range(vvv[key].nLumiBins):\n",
    "        print('best fit for var = {0} in lumi bin = {1} is : {2} '.format(vvv[key].vname , i+1 , vvv[key].fitResults[i].bestFit))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "25ecc8d9",
   "metadata": {},
   "outputs": [],
   "source": [
    "for i in range len(vvv['nPhotons']._subRuns):\n",
    "    x = vvv['nPhotons'].run\n",
    "    print(x)\n",
    "# vvv['nPhotons']._run"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "691dd84f",
   "metadata": {},
   "outputs": [],
   "source": [
    "x = vvv['nPhotons'].subRunNumbers\n",
    "print(x)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "16385743",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt = vvv['nPhotons'].lumi_distribution.plot\n",
    "plt()\n",
    "# len(vvv['nPhotons']._subRuns)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "78fe451a",
   "metadata": {},
   "outputs": [],
   "source": [
    "for key in vvv:\n",
    "    for i in range(vvv[key].nLumiBins):\n",
    "        if i == 3 - 1:\n",
    "            print('best fit for var = {0} in lumi bin = {1} is : {2} '.format(vvv[key].vname , i+1 , vvv[key].fitResults[i].bestFit))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c92a5913",
   "metadata": {},
   "outputs": [],
   "source": [
    "#total plots export\n",
    "\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import plotly.express as px\n",
    "\n",
    "\n",
    "XsecBestTot = {}\n",
    "keys = []\n",
    "values = []\n",
    "nVar = len(variables.keys())\n",
    "print(nVar)\n",
    "for key in vvv:\n",
    "    for i in range(vvv[key].nLumiBins):\n",
    "#         print(i)\n",
    "        if i == 20 - 1:\n",
    "            print(i)\n",
    "print(vvv[key].nLumiBins)\n",
    "for i in range(vvv[key].nLumiBins):\n",
    "    for key in vvv:\n",
    "#         keys.append('{0} for lumi bin = {1} '.format(vvv[key].vname , i+1))\n",
    "        keys.append(vvv[key].vname)\n",
    "        values.append(vvv[key].fitResults[i].bestFit)\n",
    "#     print('values for bin = {0} is: {1}'.format(i+1 , values))\n",
    "#     print('------------------------------------')\n",
    "#     print('variables for bin = {0} is: {1}'.format(i+1 , keys))\n",
    "#     print('------------------------------------')\n",
    "    XsecBest= {}\n",
    "    for q in range(len(keys)):\n",
    "        XsecBest[keys[q]] = values[q]\n",
    "    \n",
    "#     print('Dict for bin = {0} is: {1}'.format(i+1 , XsecBest))\n",
    "#     print('------------------------------------')\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "    names = list(XsecBest.keys())\n",
    "    values = list(XsecBest.values())\n",
    "\n",
    "\n",
    "    #         print('best fit for var = {0} in lumi bin = {1} is : {2} '.format(vvv[key].vname , i+1 , vvv[key].fitResults[i].bestFit))\n",
    "\n",
    "    plt.plot(names , values ,'o-' , label='lumi bin = {0}'.format(i+1))\n",
    "    plt.xticks(rotation=90)\n",
    "\n",
    "    plt.xlabel(\"Variable\")\n",
    "    plt.ylabel(\"Xsection\")\n",
    "    plt.title(\"Best Xsection for different variables for different lumi bins for MCTune = 5\")\n",
    "\n",
    "    y_est = 69.2 #cross section\n",
    "    y_err = 69.2*.046 #cross section error\n",
    "\n",
    "    plt.plot(y_est, '-')\n",
    "    plt.fill_between(names, y_est - y_err, y_est + y_err, alpha=0.2 , label = u'69.2 \\u00B1 4.6%' )\n",
    "\n",
    "    plt.legend(loc='center left', bbox_to_anchor=(1.2, 0.5))\n",
    "#     plt.show()\n",
    "    plt.savefig('{0}/totallumi.png'.format(web2) , dpi=300, bbox_inches='tight')   # save the figure to file\n",
    "#     plt.close(fig)\n",
    "    \n",
    "#     fig.write_html('/plot for lumi =1')\n",
    "\n",
    "#     plt.savefig('XSection Best fit for lumi = {0}.png'.format(i+1))\n",
    "    keys = []\n",
    "    values = []\n",
    "# print(keys)\n",
    "# print(values)\n",
    "#     print(values)\n",
    "for i in range(len(keys)):\n",
    "    XsecBestTot[keys[i]] = values[i]\n",
    "\n",
    "# print(XsecBestTot)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e9012bd6",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "71b40edc",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a0f82962",
   "metadata": {},
   "outputs": [],
   "source": [
    "#plot for each lumi bin\n",
    "\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import plotly.express as px\n",
    "\n",
    "\n",
    "XsecBestTot = {}\n",
    "keys = []\n",
    "values = []\n",
    "nVar = len(variables.keys())\n",
    "print(nVar)\n",
    "\n",
    "for i in range(vvv[key].nLumiBins):\n",
    "    for key in vvv:\n",
    "#         keys.append('{0} for lumi bin = {1} '.format(vvv[key].vname , i+1))\n",
    "        keys.append(vvv[key].vname)\n",
    "        values.append(vvv[key].fitResults[i].bestFit)\n",
    "#     print('values for bin = {0} is: {1}'.format(i+1 , values))\n",
    "#     print('------------------------------------')\n",
    "#     print('variables for bin = {0} is: {1}'.format(i+1 , keys))\n",
    "#     print('------------------------------------')\n",
    "    XsecBest= {}\n",
    "    for q in range(len(keys)):\n",
    "        XsecBest[keys[q]] = values[q]\n",
    "    \n",
    "#     print('Dict for bin = {0} is: {1}'.format(i+1 , XsecBest))\n",
    "#     print('------------------------------------')\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "    names = list(XsecBest.keys())\n",
    "    values = list(XsecBest.values())\n",
    "\n",
    "\n",
    "    #         print('best fit for var = {0} in lumi bin = {1} is : {2} '.format(vvv[key].vname , i+1 , vvv[key].fitResults[i].bestFit))\n",
    "\n",
    "    plt.plot(names , values ,'o-' , color='tab:brown' , label='lumi bin = {0}'.format(i+1))\n",
    "    plt.xticks(rotation=90)\n",
    "\n",
    "    plt.xlabel(\"Variable\")\n",
    "    plt.ylabel(\"Xsection\")\n",
    "    plt.title(\"Best Xsection for different variables for lumi bin = {0} (MCTune = 5)\".format(i+1))\n",
    "\n",
    "    y_est = 69.2 #cross section\n",
    "    y_err = 69.2*.046 #cross section error\n",
    "\n",
    "    plt.plot(y_est, '-')\n",
    "    plt.fill_between(names, y_est - y_err, y_est + y_err, alpha=0.2 , label = u'69.2 \\u00B1 4.6%' )\n",
    "\n",
    "    plt.legend()\n",
    "    plt.savefig('{0}/plot for lumi = {1}.png'.format(web2,i+1) , dpi=300, bbox_inches='tight')\n",
    "    plt.show()\n",
    "\n",
    "    \n",
    "#     fig.write_html('/plot for lumi =1')\n",
    "\n",
    "#     plt.savefig('XSection Best fit for lumi = {0}.png'.format(i+1))\n",
    "    keys = []\n",
    "    values = []\n",
    "# print(keys)\n",
    "# print(values)\n",
    "#     print(values)\n",
    "for i in range(len(keys)):\n",
    "    XsecBestTot[keys[i]] = values[i]\n",
    "\n",
    "# print(XsecBestTot)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "844234bb",
   "metadata": {},
   "outputs": [],
   "source": [
    "#plot for each lumi bin\n",
    "\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import plotly.express as px\n",
    "\n",
    "\n",
    "XsecBestTot = {}\n",
    "keys = []\n",
    "values = []\n",
    "nVar = len(variables.keys())\n",
    "print(nVar)\n",
    "\n",
    "for i in range(vvv[key].nLumiBins):\n",
    "    for key in vvv:\n",
    "#         keys.append('{0} for lumi bin = {1} '.format(vvv[key].vname , i+1))\n",
    "        keys.append(vvv[key].vname)\n",
    "        values.append(vvv[key].fitResults[i].bestFit)\n",
    "#     print('values for bin = {0} is: {1}'.format(i+1 , values))\n",
    "#     print('------------------------------------')\n",
    "#     print('variables for bin = {0} is: {1}'.format(i+1 , keys))\n",
    "#     print('------------------------------------')\n",
    "    XsecBest= {}\n",
    "    for q in range(len(keys)):\n",
    "        XsecBest[keys[q]] = values[q]\n",
    "    \n",
    "#     print('Dict for bin = {0} is: {1}'.format(i+1 , XsecBest))\n",
    "#     print('------------------------------------')\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "    names = list(XsecBest.keys())\n",
    "    values = list(XsecBest.values())\n",
    "\n",
    "\n",
    "    #         print('best fit for var = {0} in lumi bin = {1} is : {2} '.format(vvv[key].vname , i+1 , vvv[key].fitResults[i].bestFit))\n",
    "\n",
    "    plt.plot(names , values ,'o-' , color='tab:brown' , label='lumi bin = {0}'.format(i+1))\n",
    "    plt.xticks(rotation=90)\n",
    "\n",
    "    plt.xlabel(\"Variable\")\n",
    "    plt.ylabel(\"Xsection\")\n",
    "    plt.title(\"Best Xsection for different variables for lumi bin = {0} (MCTune = 5)\".format(i+1))\n",
    "\n",
    "\n",
    "\n",
    "    plt.legend()\n",
    "#     plt.savefig('/eos/user/c/cmstandi/www/PU/newres/data2/5/plot for lumi = {}.png'.format(i+1) , dpi=300, bbox_inches='tight')\n",
    "    plt.show()\n",
    "\n",
    "    \n",
    "#     fig.write_html('/plot for lumi =1')\n",
    "\n",
    "#     plt.savefig('XSection Best fit for lumi = {0}.png'.format(i+1))\n",
    "    keys = []\n",
    "    values = []\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "42cbe91d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "plt.style.use('seaborn-white')\n",
    "import numpy as np\n",
    "keys= []\n",
    "for i in range(vvv[key].nLumiBins):\n",
    "    for key in vvv:\n",
    "#         keys.append('{0} for lumi bin = {1} '.format(vvv[key].vname , i+1))\n",
    "        keys.append(vvv[key].vname)\n",
    "names = keys \n",
    "def f(x ,y):\n",
    "    return np.sin(y) ** 10 + np.cos(y)\n",
    "x = np.array(names)\n",
    "y = np.array([1, 2,3,4,5,6])\n",
    "\n",
    "X, Y = np.meshgrid(x, y)\n",
    "Z = f(X, Y)\n",
    "plt.contourf(x, y, Z, 20, cmap='RdGy')\n",
    "plt.xticks(rotation=90)\n",
    "\n",
    "plt.colorbar()\n",
    "# print(vvv['fixedGridRhoAll'].fitResults[0].bestFit)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9ee272fb",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "plt.style.use('seaborn-white')\n",
    "import numpy as np\n",
    "keys= []\n",
    "values = []\n",
    "for i in range(vvv[key].nLumiBins):\n",
    "    for key in vvv:\n",
    "#         keys.append('{0} for lumi bin = {1} '.format(vvv[key].vname , i+1))\n",
    "        keys.append(vvv[key].vname)\n",
    "        values.append(vvv[key].fitResults[i].bestFit)\n",
    "names = keys \n",
    "# print(names)\n",
    "print(len(names))\n",
    "# print(values)\n",
    "print(len(values))\n",
    "\n",
    "\n",
    "\n",
    "def f(x ,y):\n",
    "    for name in names:\n",
    "        for i in range(vvv[key].nLumiBins):\n",
    "            return y  + vvv[name].fitResults[i].bestFit\n",
    "\n",
    "\n",
    "x = np.array(names)\n",
    "print(x[0])\n",
    "y = range(1,vvv[key].nLumiBins+1)\n",
    "# print(y)\n",
    "X, Y = np.meshgrid(x, y)\n",
    "Z = f(X, Y)\n",
    "plt.contourf(x, y, Z, 20, cmap='RdGy')\n",
    "plt.xticks(rotation=90)\n",
    "plt.xlabel(\"Variable\")\n",
    "plt.ylabel(\"lumi bin\")\n",
    "plt.colorbar()\n",
    "# print(vvv['fixedGridRhoAll'].fitResults[0].bestFit)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7748726f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# import numpy as np\n",
    "# import matplotlib.pyplot as plt\n",
    "# import plotly.express as px\n",
    "\n",
    "\n",
    "# XsecBestTot = {}\n",
    "# keys = []\n",
    "# values = []\n",
    "# nVar = len(variables.keys())\n",
    "# print(nVar)\n",
    "\n",
    "# def f(x ,y):\n",
    "#     return np.sin(y) ** 10 + np.cos(y)\n",
    "\n",
    "\n",
    "# for i in range(vvv[key].nLumiBins):\n",
    "#     for key in vvv:\n",
    "#         keys.append(vvv[key].vname)\n",
    "#         values.append(vvv[key].fitResults[i].bestFit)\n",
    "\n",
    "#     XsecBest= {}\n",
    "#     for q in range(len(keys)):\n",
    "#         XsecBest[keys[q]] = values[q]\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "#     names = list(XsecBest.keys())\n",
    "#     values = list(XsecBest.values())\n",
    "\n",
    "\n",
    "#     #         print('best fit for var = {0} in lumi bin = {1} is : {2} '.format(vvv[key].vname , i+1 , vvv[key].fitResults[i].bestFit))\n",
    "\n",
    "# #     plt.plot(names , values ,'o' , color='tab:brown' , label='lumi bin = {0}'.format(i+1))\n",
    "#     plt.xticks(rotation=90)\n",
    "\n",
    "#     plt.xlabel(\"Variable\")\n",
    "#     plt.ylabel(\"lumi bin\")\n",
    "#     plt.title(\"Best Xsection for different variables for lumi bin = {0} (MCTune = 5)\".format(i+1))\n",
    "#     y = i\n",
    "    \n",
    "#     Z = f(X, Y)\n",
    " \n",
    "# #     plt.legend()\n",
    "# #     plt.savefig('/eos/user/c/cmstandi/www/PU/newres/data2/5/plot for lumi = {}.png'.format(i+1) , dpi=300, bbox_inches='tight')\n",
    "# #     plt.show()\n",
    "#     plt.contourf(names, i, Z, 20, cmap='RdGy')\n",
    "#     plt.xticks(rotation=90)\n",
    "#     plt.colorbar()\n",
    "    \n",
    "# #     fig.write_html('/plot for lumi =1')\n",
    "\n",
    "# #     plt.savefig('XSection Best fit for lumi = {0}.png'.format(i+1))\n",
    "#     keys = []\n",
    "#     values = []\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "942fd9a9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# import numpy as np\n",
    "# import matplotlib.pyplot as plt\n",
    "# import plotly.express as px\n",
    "\n",
    "\n",
    "# XsecBestTot = {}\n",
    "# keys = []\n",
    "# values = []\n",
    "# nVar = len(variables.keys())\n",
    "# print(nVar)\n",
    "\n",
    "\n",
    "# for key in vvv:\n",
    "#     keys.append(vvv[key].vname)\n",
    "#     XsecBest= {}\n",
    "#     for i in range(vvv[key].nLumiBins):\n",
    "#         values.append(vvv[key].fitResults[i].bestFit)\n",
    "\n",
    "        \n",
    "# print(keys)\n",
    "# print(values)\n",
    "\n",
    "\n",
    "# # def f(x ,y):\n",
    "# #     return vvv[x].fitResults[y].bestFit\n",
    "\n",
    "# # x = np.array(keys)\n",
    "# # y = range(vvv[key].nLumiBins+1)\n",
    "\n",
    "# for key in vvv:\n",
    "#     x = key\n",
    "#     for i in range(vvv[key].nLumiBins):\n",
    "#         y = i+1\n",
    "\n",
    "#         X, Y = np.meshgrid(x, y)\n",
    "\n",
    "#         Z = vvv[X].fitResults[Y].bestFit\n",
    "\n",
    "\n",
    "#         plt.contourf(X, Y, Z, 20, cmap='RdGy')\n",
    "#         plt.xticks(rotation=90)\n",
    "#         plt.xlabel(\"Variable\")\n",
    "#         plt.ylabel(\"Lumi bin\")\n",
    "#         plt.title(\"Best Xsection for different variables for every lumi bins\")\n",
    "#         plt.colorbar()\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# #         XsecBest[keys[q]] = values[q]\n",
    "\n",
    "# #         names = list(XsecBest.keys())\n",
    "# #         values = list(XsecBest.values())\n",
    "\n",
    "\n",
    "\n",
    "# #         plt.plot(names , values ,'o-' , color='tab:brown' , label='lumi bin = {0}'.format(i+1))\n",
    "# #         plt.xticks(rotation=90)\n",
    "\n",
    "# #         plt.xlabel(\"Variable\")\n",
    "# #         plt.ylabel(\"Xsection\")\n",
    "# #         plt.title(\"Best Xsection for different variables for lumi bin = {0} (MCTune = 5)\".format(i+1))\n",
    "\n",
    "\n",
    "\n",
    "# #         plt.plot(y_est, '-')\n",
    "# #         plt.fill_between(names, y_est - y_err, y_est + y_err, alpha=0.2 , label = u'69.2 \\u00B1 4.6%' )\n",
    "\n",
    "# #         plt.legend()\n",
    "# #     #     plt.savefig('/eos/user/c/cmstandi/www/PU/newres/data2/4/plot for lumi = {}.png'.format(i+1) , dpi=300, bbox_inches='tight')\n",
    "# #     #     plt.show()\n",
    "\n",
    "# #         XsecBestTot[keys[i]] = values[i]\n",
    "# #         keys = []\n",
    "# #         values = []\n",
    "# #     print(keys)\n",
    "# #     print(values)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "93e9254b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# import numpy as np\n",
    "# import matplotlib.pyplot as plt\n",
    "\n",
    "\n",
    "# XsecBest = {}\n",
    "# keys = []\n",
    "# values = []\n",
    "# nVar = len(variables.keys())\n",
    "# print(nVar)\n",
    "\n",
    "# for i in range(vvv[key].nLumiBins):\n",
    "#     for key in vvv:\n",
    "#         keys.append(vvv[key].vname)\n",
    "#         values.append(vvv[key].fitResults[i].bestFit)\n",
    "\n",
    "        \n",
    "        \n",
    "        \n",
    "# print(keys)\n",
    "# print(values)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "089dfb99",
   "metadata": {},
   "outputs": [],
   "source": [
    "# import numpy as np\n",
    "# import matplotlib.pyplot as plt\n",
    "\n",
    "\n",
    "# XsecBest = {}\n",
    "# keys = []\n",
    "# values = []\n",
    "# nVar = len(variables.keys())\n",
    "# print(nVar)\n",
    "# for key in vvv:\n",
    "# #     print(vvv[key].vname)\n",
    "#     for i in range(vvv[key].nLumiBins):\n",
    "#         keys.append(vvv[key].vname)\n",
    "#         values.append(vvv[key].fitResults[i].bestFit)\n",
    "# # print(keys)\n",
    "# # print(values)\n",
    "\n",
    "\n",
    "# for i in range(len(keys)):\n",
    "#     XsecBest[keys[i]] = values[i]\n",
    "# # print(XsecBest)\n",
    "\n",
    "# names = list(XsecBest.keys())\n",
    "# values = list(XsecBest.values())\n",
    "\n",
    "\n",
    "# #         print('best fit for var = {0} in lumi bin = {1} is : {2} '.format(vvv[key].vname , i+1 , vvv[key].fitResults[i].bestFit))\n",
    "\n",
    "# plt.plot(names , values ,'o-' , color='tab:brown' , label='lumi bin = {0}'.format(i))\n",
    "# # plt.bar(range(len(XsecBest)), values, tick_label=names)\n",
    "# plt.xticks(rotation=90)\n",
    "\n",
    "# plt.xlabel(\"Variable\")\n",
    "# plt.ylabel(\"Xsection\")\n",
    "# plt.title(\"Best Xsection for different variables\")\n",
    "\n",
    "# y_est = 69.2 #cross section\n",
    "# y_err = 4.6 #cross section error\n",
    "\n",
    "# plt.plot(y_est, '-')\n",
    "# plt.fill_between(names, y_est - y_err, y_est + y_err, alpha=0.2 , label = u'69.2 \\u00B1 4.6' )\n",
    "\n",
    "# plt.legend()\n",
    "# plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0235b922",
   "metadata": {},
   "outputs": [],
   "source": [
    "for i in range (vvv['nVertices'].nLumiBins):\n",
    "    print(vvv['nVertices'].data_hists[i].integral())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e47f3a7a",
   "metadata": {},
   "outputs": [],
   "source": [
    "vvv['nVertices'].predictions[0].plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "33f677ad",
   "metadata": {},
   "outputs": [],
   "source": [
    "vvv['nVertices'].predictions[0].plot(param=vvv['nVertices'].fitResults[0].bestFit ,\n",
    "                                    norm=vvv['nVertices'].data_hists[0].integral()\n",
    "                                    )\n",
    "vvv['nVertices'].predictions[0].plot(norm=vvv['nVertices'].data_hists[0].integral() ,param=vvv['nVertices'].fitResults[0].bestFit)\n",
    "prelist = vvv['nVertices'].predictions[0].allProbs()\n",
    "print(prelist)\n",
    "print(sum(prelist))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3dc8b1cd",
   "metadata": {},
   "outputs": [],
   "source": [
    "vvv['nVertices'].data_hists[0].plot()\n",
    "datalist =(vvv['nVertices'].data_hists[0].allProbs())/(vvv['nVertices'].data_hists[0].integral())\n",
    "print(datalist)\n",
    "print(sum(datalist))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1e8d9404",
   "metadata": {},
   "outputs": [],
   "source": [
    "n = 0\n",
    "for i in range(len(datalist)):\n",
    "#     print(datalist[i])\n",
    "#     print(prelist[i])\n",
    "# #     print('-------')\n",
    "    if datalist[i] == 0 :\n",
    "        pass\n",
    "    else: \n",
    "        m = datalist[i] - prelist[i]\n",
    "        k = m**2\n",
    "        j = k/datalist[i]\n",
    "        print(j)\n",
    "        n += j\n",
    "        print(n)\n",
    "        m = 0\n",
    "        print('-----------')\n",
    "print(n)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b3846e7f",
   "metadata": {},
   "outputs": [],
   "source": [
    "import math \n",
    "n = 0\n",
    "for i in range(len(datalist)):\n",
    "#     print(datalist[i])\n",
    "#     print(prelist[i])\n",
    "# #     print('-------')\n",
    "    if datalist[i] == 0 :\n",
    "        pass\n",
    "    else: \n",
    "        m = datalist[i] - prelist[i]\n",
    "        j = m/math.sqrt(datalist[i])\n",
    "        n += j\n",
    "        m = 0\n",
    "print(n)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9feb25a6",
   "metadata": {},
   "outputs": [],
   "source": [
    "#  vvv['nVertices']._subRunsSameLumiBins[0].fitResults"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c8c3b112",
   "metadata": {},
   "outputs": [],
   "source": [
    "# vvv['nVertices'].fitResults[3].plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6d52a700",
   "metadata": {},
   "outputs": [],
   "source": [
    "# vvv['nVertices'].predictions[0] "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7ea4f01f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# vvv['nVertices'].data_hists[0]\n",
    "# print(vvv['fixedGridRhoAll'].nLumiBins)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "91ebe59a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# vvv['nVertices'].fitResults"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4f4ed2ab",
   "metadata": {},
   "outputs": [],
   "source": [
    "# vvv['nVertices'].fitResults"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7fbde913",
   "metadata": {},
   "outputs": [],
   "source": [
    "# simDist = SimulationVSPu('nPhotons' , year = 2018 , var_bins= np.linspace(0,100,101) , pu_max=100 , nthreads=30)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fe24cfc6",
   "metadata": {},
   "outputs": [],
   "source": [
    "# aa = simDist.plotEfficiencies()\n",
    "# aa.plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f386dc04",
   "metadata": {},
   "outputs": [],
   "source": [
    "# for key in variables.keys():\n",
    "#     print('vName: {0}'.format(key))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7a26a9a1",
   "metadata": {},
   "outputs": [],
   "source": [
    "# MC = SimulationVSPu.mctune\n",
    "# print(MC)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ab179661",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
